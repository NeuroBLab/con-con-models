import pandas as pd
import numpy as np

import ccmodels.dataanalysis.filters as fl


# ---------------------------------------------------------------------------------
# ------------------ EXTRA INFO TO THE CONNECTION TABLE --------------------------- 
# ---------------------------------------------------------------------------------


def add_layerinfo_to_connections(v1_neurons, v1_connections, who="pre"):
    """
    Add columns to the v1_connections table in order to know the layer of pre and post synaptic neurons
    immediately. Set which ones to add by setting the argument who="pre", "post" or "both".
    """

    #Avoid modifying the original, by copying
    v1_conn_withlayer = v1_connections.copy() 

    #The same thing for pre and post: add the respective columns...
    if who == "pre" or who == "both":
        #Create a new column and fill it with a default value
        v1_conn_withlayer["pre_layer"] = "L23"

        #Then, search all neurons in L4 and set them in the new table
        #l4_neurons_ids = filter_neurons(v1_neurons, layer="L4")["id"]
        #mask_l4 = v1_conn_withlayer["pre_id"].isin(l4_neurons_ids)

        #Then, obtained the indices of all connections with presynaptic neurons in L4 and set them in the new table
        mask_l4 = fl.filter_connections(v1_neurons, v1_connections, layer="L4").index.values
        v1_conn_withlayer.loc[mask_l4, "pre_layer"] = "L4"

    if who == "post" or who == "both":
        #By definition, the way we constructed the data, no postsynaptic neuron is in L4, so just fill it up!!
        v1_conn_withlayer["post_layer"] = "L23"

    
    #Return result
    return v1_conn_withlayer


def tuning_encoder(v1_neurons, v1_connections):
    '''
    Takes the neurons and synapses properties. Returns a table with two columns, pre_tuned and post_tuned, 
    which are True when the corresponding neuron is tuned. 

    Returns: 
    Updated v1_connections including new columns pre_tuned and post_tuned for the tuning of 
    the pre and post synaptic neurons, respectively
    '''

    #Get the neurons which are tuned
    tuned_neurons_ids = fl.filter_neurons(v1_neurons, tuning="tuned")["id"]

    #Initialize a new table with the tuning set to false by default
    v1_conn_withtuning = v1_connections.copy()
    v1_conn_withtuning["pre_tuned"] = False
    v1_conn_withtuning["post_tuned"] = False

    #Look which IDs of pre and post synaptic neurons are inside of the tuned IDs we got, and set those to true
    v1_conn_withtuning.loc[v1_conn_withtuning["pre_id"].isin(tuned_neurons_ids), "pre_tuned"] = True
    v1_conn_withtuning.loc[v1_conn_withtuning["post_id"].isin(tuned_neurons_ids), "post_tuned"] = True

    return v1_conn_withtuning




# ------------------------------------------------------------
# ----------------------- TUNING HELPERS ---------------------
# ------------------------------------------------------------


def split_by_tuning(v1_connections):
    """
    Utility function that generates a single Pandas dataframe for each combination of tuned-untuned connectivity by layer,
    i.e., returns a table containing only L2/3 TUNED to L2/3 TUNED, L4 UNTUNED to L2/3 TUNED, and so on...

    Parameters:
    v1_connections: the list of connections between neurons. Must include information about the layer of the
    presynaptic neurons, which can be obtained by add_layerinfo_to_connections
    c_tuning: generated by tuning_encoder, a table indicating the tuning of each synapse
    """

    tables = {}

    #Are the pre and post neurons tuned or not?
    tuned_tuned = v1_connections['pre_tuned']   &  v1_connections['post_tuned']  
    tuned_untun = v1_connections['pre_tuned']   &  ~v1_connections['post_tuned'] 
    untun_tuned = ~v1_connections['pre_tuned']  &  v1_connections['post_tuned']  
    untun_untun = ~v1_connections['pre_tuned']  &  ~v1_connections['post_tuned']  

    #Which ones is the presynaptic thing coming from?
    l4  = v1_connections['pre_layer'] == 'L4'
    l23 = v1_connections['pre_layer'] == 'L23'


    #L4 -> L2/3
    tables["l4t_l23t"] =  v1_connections[tuned_tuned & l4]
    tables["l4t_l23u"] =  v1_connections[tuned_untun & l4]
    tables["l4u_l23t"] =  v1_connections[untun_tuned & l4]
    tables["l4u_l23u"] =  v1_connections[untun_untun & l4]

    #L2/3 -> L2/3      
    tables["l23t_l23t"] =  v1_connections[tuned_tuned & l23]
    tables["l23t_l23u"] =  v1_connections[tuned_untun & l23]
    tables["l23u_l23t"] =  v1_connections[untun_tuned & l23]
    tables["l23u_l23u"] =  v1_connections[untun_untun & l23]

    return tables 


# ------------------------------------------------------------
# ---------------------- ACTIVITY HELPER -----------------
# ------------------------------------------------------------

def shift_rates(v1_neurons, pre_ids, post_id, rates):
    """
    Shift all the rates corresponding to the pre_ids, so that the post_id neuron
    would be oriented at angle = 0.

    Parameters
    v1_neurons : DataFrame
        The table with info of all the neurons.
    pre_ids : arraylike
        An array with all the ids of the considered presynaptic neurons 
    post_id : int
        The selected postsynaptic neuron id
    rates : numpy matrix
        The matrix with the rates information
    """
    if isinstance(post_id, (int, float, np.int64, np.float64)): 
        rates_selected = rates[pre_ids, :]
        post_pref_ori  = v1_neurons.loc[post_id, "pref_ori"]
        return  np.roll(rates_selected, -post_pref_ori, axis=1) 
    else:
        raise ValueError("shift_rates accepts only a scalar (int) postsynaptic id to work.")

def shift_multi(rates, rollamount):
    """
    Perform a roll for each one of the rows of the vector rates by
    the quantities defined in rollamount

    Parameters
    ==========
    rates : numpy array NxM
        An array to be reshuffled 
    rollamount : numpy array N
        rollamount[i] says how much to roll rates[i, :]
    """

    return np.array([np.roll(rates[i, :], -r) for i,r in enumerate(rollamount)])



def shuffle_neurons(ids, rates):
    """
    Shuffle the rates of the selected neurons, taken by their id 
    """
    #Shuffle the selected columns (inplace) 
    for id in ids:
        np.random.shuffle(rates[id, :])

    return 


def get_untuned_rate(v1_neurons, rates):
    """
    Returns a modified rate matrix where the rows corresponding to untuned neurons
    are set to their average 
    """

    #Find the untuned neurons
    untuned_ids = fl.filter_neurons(v1_neurons, tuning="untuned")["id"]
    rates_unt = rates.copy()
    #Substitute the not tuned ones with the mean rate accross all its angles
    #The newaxis thing allows it to be assigned doing rates[ids, :] = directly
    rates_unt[untuned_ids, :] = np.mean(rates[untuned_ids, :], axis=1)[:, np.newaxis]   
    return rates_unt


